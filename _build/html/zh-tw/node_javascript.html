
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>JavaScript 與 NodeJS &mdash; The Little Node.js Book</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="top" title="The Little Node.js Book" href="../index.html" />
    <link rel="next" title="Node.js 安裝與設定" href="node_install.html" />
    <link rel="prev" title="Node.js 簡介" href="node_introduce.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="node_install.html" title="Node.js 安裝與設定"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="node_introduce.html" title="Node.js 簡介"
             accesskey="P">上一頁</a> |</li>
        <li><a href="../index.html">The Little Node.js Book</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">

          <div class="body">
          
            <!-- AddThis Button BEGIN -->
            <div class="addthis_toolbox addthis_default_style ">
            <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
            <a class="addthis_button_tweet"></a>
            <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
            <a class="addthis_counter addthis_pill_style"></a>
            </div>
            <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid=ra-4f5b8b345526ee62"></script>
            <!-- AddThis Button END -->
          
            
  <div class="section" id="javascript-nodejs">
<h1>JavaScript 與 NodeJS<a class="headerlink" href="#javascript-nodejs" title="Permalink to this headline">¶</a></h1>
<p>其實使用 JavaScript 在網頁端與伺服器端的差距並不大，
但是為了使 NodeJS 可以發揮他最強大的能力，
有一些知識還是必要的，
所以還是針對這些主題介紹一下。
其中 Event Loop、Scope 以及 Callback 其實是比較需要了解的基本知識，
cps、currying、flow control是更進階的技巧與應用。</p>
<div class="section" id="event-loop">
<h2>Event Loop<a class="headerlink" href="#event-loop" title="Permalink to this headline">¶</a></h2>
<p>可能很多人在寫Javascript時，並不知道他是怎麼被執行的。這個時候可以參考一下jQuery作者John Resig一篇好文章，介紹事件及timer怎麼在瀏覽器中執行：How JavaScript Timers Work。通常在網頁中，所有的Javascript執行完畢後（這部份全部都在global scope跑，除非執行函數），接下來就是如John Resig解釋的這樣，所有的事件處理函數，以及timer執行的函數，會排在一個queue結構中，利用一個無窮迴圈，不斷從queue中取出函數來執行。這個就是event loop。</p>
<p>（除了John Resig的那篇文章，Nicholas C. Zakas的 &#8220;Professional Javascript for Web Developer 2nd edition&#8221; 有一個試閱本：http://yuiblog.com/assets/pdf/zakas-projs-2ed-ch18.pdf，598頁剛好也有簡短的說明）</p>
<p>所以在Javascript中，雖然有非同步，但是他並不是使用執行緒。所有的事件或是非同步執行的函數，都是在同一個執行緒中，利用event loop的方式在執行。至於一些比較慢的動作例如I/O、網頁render, reflow等，實際動作會在其他執行緒跑，等到有結果時才利用事件來觸發處理函數來處理。這樣的模型有幾個好處：
沒有執行緒的額外成本，所以反應速度很快
不會有任何程式同時用到同一個變數，不必考慮lock，也不會產生dead lock
所以程式撰寫很簡單
但是也有一些潛在問題：
任一個函數執行時間較長，都會讓其他函數更慢執行（因為一個跑完才會跑另一個）
在多核心硬體普遍的現在，無法用單一的應用程式instance發揮所有的硬體能力
用NodeJS撰寫伺服器程式，碰到的也是一樣的狀況。要讓系統發揮event loop的效能，就要盡量利用事件的方式來組織程式架構。另外，對於一些有可能較為耗時的操作，可以考慮使用 process.nextTick 函數來讓他以非同步的方式執行，避免在同一個函數中執行太久，擋住所有函數的執行。</p>
<p>如果想要測試event loop怎樣在「瀏覽器」中運行，可以在函數中呼叫alert()，這樣會讓所有Javascript的執行停下來，尤其會干擾所有使用timer的函數執行。有一個簡單的例子，這是一個會依照設定的時間間隔嚴格執行動作的動畫，如果時間過了就會跳過要執行的動作。點按圖片以後，人物會快速旋轉，但是在旋轉執行完畢前按下「delay」按鈕，讓alert訊息等久一點，接下來的動畫就完全不會出現了。</p>
</div>
<div class="section" id="scope-closure">
<h2>Scope 與 Closure<a class="headerlink" href="#scope-closure" title="Permalink to this headline">¶</a></h2>
<p>要快速理解 JavaScript 的 Scope（變數作用範圍）原理，只要記住他是Lexical Scope就差不多了。簡單地說，變數作用範圍是依照程式定義時（或者叫做程式文本？）的上下文決定，而不是執行時的上下文決定。</p>
<p>為了維護程式執行時所依賴的變數，即使執行時程式運行在原本的scope之外，他的變數作用範圍仍然維持不變。這時程式依賴的自由變數（定義時不是local的，而是在上一層scope定義的變數）一樣可以使用，就好像被關閉起來，所以叫做Closure。用程式看比較好懂：</p>
<div class="highlight-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">outter</span><span class="p">(</span><span class="nx">arg1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//arg1及free_variable1對inner函數來說，都是自由變數</span>
    <span class="kd">var</span> <span class="nx">free_variable1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nx">inner</span><span class="p">(</span><span class="nx">arg2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">local_variable1</span> <span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="c1">//arg2及local_variable1對inner函數來說，都是本地變數</span>
        <span class="k">return</span> <span class="nx">arg1</span> <span class="o">+</span> <span class="nx">arg2</span> <span class="o">+</span> <span class="nx">free_variable</span> <span class="o">+</span> <span class="nx">local_variable1</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>var a = outter(1);//變數a 就是outter函數執行後返回的inner函數
var b = a(4);//執行inner函數，執行時上下文已經在outter函數之外，但是仍然能正常執行，而且可以使用定義在outter函數裡面的arg1及free_variable1變數
console.log(b);//結果10</p>
<p>在Javascript中，scope最主要的單位是函數（另外有global及eval），所以有可能製造出closure的狀況，通常在形式上都是有巢狀的函數定義，而且內側的函數使用到定義在外側函數裡面的變數。</p>
<p>Closure有可能會造成記憶體洩漏，主要是因為被參考的變數無法被垃圾收集機制處理，造成佔用的資源無法釋放，所以使用上必須考慮清楚，不要造成意外的記憶體洩漏。（在上面的例子中，如果a一直未執行，使用到的記憶體就不會被釋放）</p>
<p>跟透過函數的參數把變數傳給函數比較起來，Javascript Engine會比較難對Closure進行最佳化。如果有效能上的考量，這一點也需要注意。</p>
</div>
<div class="section" id="callback">
<h2>Callback<a class="headerlink" href="#callback" title="Permalink to this headline">¶</a></h2>
<p>要介紹 Callback 之前，
要先提到 JavaScript 的特色。</p>
<p>JavaScript 是一種函數式語言（functional language），所有Javascript語言內的函數，都是高階函數(higher order function，這是數學名詞，計算機用語好像是first class function，意指函數使用沒有任何限制，與其他物件一樣)。也就是說，函數可以作為函數的參數傳給函數，也可以當作函數的返回值。這個特性，讓Javascript的函數，使用上非常有彈性，而且功能強大。</p>
<p>callback在形式上，其實就是把函數傳給函數，然後在適當的時機呼叫傳入的函數。Javascript使用的事件系統，通常就是使用這種形式。NodeJS中，有一個物件叫做EventEmitter，這是NodeJS事件處理的核心物件，所有會使用事件處理的函數，都會「繼承」這個物件。（這裡說的繼承，實作上應該像是mixin）他的使用很簡單：
可以使用 物件.on(事件名稱, callback函數) 或是 物件.addListener(事件名稱, callback函數) 把你想要處理事件的函數傳入
在 物件 中，可以使用 物件.emit(事件名稱, 參數...) 呼叫傳入的callback函數
這是Observer Pattern的簡單實作，而且跟在網頁中使用DOM的addEventListener使用上很類似，也很容易上手。不過NodeJS是大量使用非同步方式執行的應用，所以程式邏輯幾乎都是寫在callback函數中，當邏輯比較複雜時，大量的callback會讓程式看起來很複雜，也比較難單元測試。舉例來說：</p>
<p>var p_client = new Db(&#8216;integration_tests_20&#8217;, new Server(&#8220;127.0.0.1&#8221;, 27017, {}), {&#8216;pk&#8217;:CustomPKFactory});
p_client.open(function(err, p_client) {</p>
<blockquote>
<div><dl class="docutils">
<dt>p_client.dropDatabase(function(err, done) {</dt>
<dd><dl class="first docutils">
<dt>p_client.createCollection(&#8216;test_custom_key&#8217;, function(err, collection) {</dt>
<dd><dl class="first docutils">
<dt>collection.insert({&#8216;a&#8217;:1}, function(err, docs) {</dt>
<dd><dl class="first docutils">
<dt>collection.find({&#8216;_id&#8217;:new ObjectID(&#8220;aaaaaaaaaaaa&#8221;)}, function(err, cursor) {</dt>
<dd><dl class="first docutils">
<dt>cursor.toArray(function(err, items) {</dt>
<dd>test.assertEquals(1, items.length);
p_client.close();</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<p>});</p>
</div></blockquote>
<p>});</p>
<p>這是在網路上看到的一段操作mongodb的程式碼，為了循序操作，所以必須在一個callback裡面呼叫下一個動作要使用的函數，這個函數裡面還是會使用callback，最後就形成一個非常深的巢狀。</p>
<p>這樣的程式碼，會比較難進行單元測試。有一個簡單的解決方式，是盡量不要使用匿名函數來當作callback或是event handler。透過這樣的方式，就可以對各個handler做單元測試了。例如：</p>
<p>var http = require(&#8216;http&#8217;);
var tools = {</p>
<blockquote>
<div>cookieParser: function(request, response) {
if(request.headers[&#8216;Cookie&#8217;]) {
//do parsing
}
}</div></blockquote>
<p>};
var server = http.createServer(function(request, response) {</p>
<blockquote>
<div>this.emit(&#8216;init&#8217;, request, response);
//...</div></blockquote>
<p>});
server.on(&#8216;init&#8217;, tools.cookieParser);
server.listen(8080, &#8216;127.0.0.1&#8217;);</p>
<p>更進一步，可以把tools改成外部module，例如叫做tools.js：</p>
<dl class="docutils">
<dt>module.exports = {</dt>
<dd>cookieParser: function(request, response) {
if(request.headers[&#8216;Cookie&#8217;]) {
//do parsing
}
}</dd>
</dl>
<p>};</p>
<p>然後把程式改成：</p>
<p>var http = require(&#8216;http&#8217;);</p>
<dl class="docutils">
<dt>var server = http.createServer(function(request, response) {</dt>
<dd>this.emit(&#8216;init&#8217;, request, response);
//...</dd>
</dl>
<p>});
server.on(&#8216;init&#8217;, require(&#8216;./tools&#8217;).cookieParser);
server.listen(8080, &#8216;127.0.0.1&#8217;);</p>
<p>這樣就可以單元測試cookieParser了。例如使用nodeunit時，可以這樣寫：</p>
<p>var testCase = require(&#8216;nodeunit&#8217;).testCase;
module.exports = testCase({</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8220;setUp&#8221;: function(cb) {</dt>
<dd><p class="first">this.request = {
headers: {
Cookie: &#8216;name1:val1; name2:val2&#8217;
}
};
this.response = {};
this.result = {name1:&#8217;val1&#8217;,name2:&#8217;val2&#8217;};</p>
<blockquote class="last">
<div>cb();</div></blockquote>
</dd>
</dl>
<p>},
&#8220;tearDown&#8221;: function(cb) {</p>
<blockquote>
<div>cb();</div></blockquote>
<p>},
&#8220;normal_case&#8221;: function(test) {</p>
<blockquote>
<div>test.expect(1);
var obj = require(&#8216;./tools&#8217;).cookieParser(this.request, this.response);
test.deepEqual(obj, this.result);
test.done();</div></blockquote>
<p>}</p>
</div></blockquote>
<p>});</p>
<p>善於利用模組，可以讓程式更好維護與測試。</p>
</div>
<div class="section" id="cps-continuation-passing-style">
<h2>CPS（Continuation-Passing Style）<a class="headerlink" href="#cps-continuation-passing-style" title="Permalink to this headline">¶</a></h2>
<p>cps是callback使用上的特例，形式上就是在函數最後呼叫callback，這樣就好像把函數執行後把結果交給callback繼續運行，所以稱作continuation-passing style。利用cps，可以在非同步執行的情況下，透過傳給callback的這個cps callback來獲知callback執行完畢，或是取得執行結果。例如：</p>
<p>&lt;html&gt;
&lt;body&gt;
&lt;div id=&#8221;panel&#8221; style=&#8221;visibility:hidden&#8221;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;script&gt;
var request = new XMLHttpRequest();
request.open(&#8216;GET&#8217;, &#8216;test749.txt?timestamp=&#8217;+new Date().getTime(), true);
request.addEventListener(&#8216;readystatechange&#8217;, function(next){</p>
<blockquote>
<div>return function() {
if(this.readyState===4&amp;&amp;this.status===200) {
next(this.responseText);//&lt;==傳入的cps callback在動作完成時執行並取得結果進一步處理
}
};</div></blockquote>
<dl class="docutils">
<dt>}(function(str){//&lt;==這個匿名函數就是cps callback</dt>
<dd>document.getElementById(&#8216;panel&#8217;).innerHTML=str;
document.getElementById(&#8216;panel&#8217;).style.visibility = &#8216;visible&#8217;;</dd>
</dl>
<p>}), false);
request.send();
&lt;/script&gt;</p>
<p>進一步的應用，也可以參考2-6 流程控制。</p>
</div>
<div class="section" id="currying">
<h2>函數返回函數與Currying<a class="headerlink" href="#currying" title="Permalink to this headline">¶</a></h2>
<p>前面的cps範例裡面，使用了函數返回函數，這是為了把cps callback傳遞給onreadystatechange事件處理函數的方法。（因為這個事件處理函數並沒有設計好會傳送/接收這樣的參數）實際會執行的事件處理函數其實是內層返回的那個函數，之外包覆的這個函數，主要是為了利用Closure，把next傳給內層的事件處理函數。這個方法更常使用的地方，是為了解決一些scope問題。例如：</p>
<p>&lt;script&gt;
var accu=0,count=10;
for(var i=0; i&lt;count; i++) {</p>
<blockquote>
<div><dl class="docutils">
<dt>setTimeout(</dt>
<dd><dl class="first docutils">
<dt>function(){</dt>
<dd><p class="first">count&#8211;;
accu+=i;
if(count&lt;=0)</p>
<blockquote class="last">
<div>console.log(accu)</div></blockquote>
</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>, 50)</p>
</div></blockquote>
<p>}
&lt;/script&gt;</p>
<p>最後得出的結果會是100，而不是想像中的45，這是因為等到setTimeout指定的函數執行時，變數i已經變成10而離開迴圈了。要解決這個問題，就需要透過Closure來保存變數i：</p>
<p>&lt;script&gt;
var accu=0,count=10;
for(var i=0; i&lt;count; i++) {</p>
<blockquote>
<div><dl class="docutils">
<dt>setTimeout(</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>function(i) {</dt>
<dd><p class="first">return function(){
count&#8211;;</p>
<blockquote>
<div><p>accu+=i;
if(count&lt;=0)</p>
<blockquote>
<div>console.log(accu)</div></blockquote>
</div></blockquote>
<p class="last">};</p>
</dd>
</dl>
</div></blockquote>
<p class="last">}(i)</p>
</dd>
</dl>
<p>, 50)</p>
</div></blockquote>
<p>}
//淺藍色底色的部份，是跟上面例子不一樣的地方
&lt;/script&gt;</p>
<p>函數返回函數的另外一個用途，是可以暫緩函數執行。例如：</p>
<dl class="docutils">
<dt>function add(m, n) {</dt>
<dd>return m+n;</dd>
</dl>
<p>}
var a = add(20, 10);
console.log(a);</p>
<p>add這個函數，必須同時輸入兩個參數，才有辦法執行。如果我希望這個函數可以先給它一個參數，等一些處理過後再給一個參數，然後得到結果，就必須用函數返回函數的方式做修改：</p>
<dl class="docutils">
<dt>function add(m) {</dt>
<dd><dl class="first docutils">
<dt>return function(n) {</dt>
<dd>return m+n;</dd>
</dl>
<p class="last">};</p>
</dd>
</dl>
<p>}
var wait_another_arg = add(20);//先給一個參數
var a = function(arr) {</p>
<blockquote>
<div>var ret=0;
for(var i=0;i&lt;arr.length;i++) ret+=arr[i];
return ret;</div></blockquote>
<p>}([1,2,3,4]);//計算一下另一個參數
var b = wait_another_arg(a);//然後再繼續執行
console.log(b);</p>
<p>像這樣利用函數返回函數，使得原本接受多個參數的函數，可以一次接受一個參數，直到參數接收完成才執行得到結果的方式，有一個學名就叫做...Currying</p>
<p>綜合以上許多奇技淫巧，就可以透過用函數來處理函數的方式，調整程式流程。接下來看看...</p>
</div>
<div class="section" id="id1">
<h2>流程控制<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>（以sync方式使用async函數、避開巢狀callback循序呼叫async callback等奇技淫巧）</p>
<p>建議參考：</p>
<ul class="simple">
<li><a class="reference external" href="http://howtonode.org/control-flow">http://howtonode.org/control-flow</a></li>
<li><a class="reference external" href="http://howtonode.org/control-flow-part-ii">http://howtonode.org/control-flow-part-ii</a></li>
<li><a class="reference external" href="http://howtonode.org/control-flow-part-iii">http://howtonode.org/control-flow-part-iii</a></li>
<li><a class="reference external" href="http://blog.mixu.net/2011/02/02/essential-node-js-patterns-and-snippets">http://blog.mixu.net/2011/02/02/essential-node-js-patterns-and-snippets</a></li>
</ul>
<p>這幾篇都是非常經典的NodeJS/Javascript流程控制好文章（阿，mixu是在介紹一些pattern時提到這方面的主題）。不過我還是用幾個簡單的程式介紹一下做法跟概念：</p>
<div class="section" id="id2">
<h3>並發與等待<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>下面的程式參考了mixu文章中的做法：</p>
<dl class="docutils">
<dt>var wait = function(callbacks, done) {</dt>
<dd>console.log(&#8216;wait start&#8217;);
var counter = callbacks.length;
var results = [];
var next = function(result) {//接收函數執行結果，並判斷是否結束執行
results.push(result);
if(&#8211;counter == 0) {
done(results);//如果結束執行，就把所有執行結果傳給指定的callback處理
}
};
for(var i = 0; i &lt; callbacks.length; i++) {//依次呼叫所有要執行的函數
callbacks[i](next);
}
console.log(&#8216;wait end&#8217;);</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>wait(</dt>
<dd>[
function(next){
setTimeout(function(){
console.log(&#8216;done a&#8217;);
var result = 500;
next(result)
},500);
},
function(next){
setTimeout(function(){
console.log(&#8216;done b&#8217;);
var result = 1000;
next(result)
},1000);
},
function(next){
setTimeout(function(){
console.log(&#8216;done c&#8217;);
var result = 1500;
next(1500)
},1500);
}
],
function(results){
var ret = 0, i=0;
for(; i&lt;results.length; i++) {
ret += results[i];
}
console.log(&#8216;done all. result: &#8216;+ret);
}</dd>
</dl>
<p>);</p>
<p>執行結果：
wait start
wait end
done a
done b
done c
done all. result: 3000</p>
<p>可以看出來，其實wait並不是真的等到所有函數執行完才結束執行，而是在所有傳給他的函數執行完畢後（不論同步、非同步），才執行處理結果的函數（也就是done()）</p>
<p>不過這樣的寫法，還不夠實用，因為沒辦法實際讓函數可以等待執行完畢，又能當作事件處理函數來實際使用。上面參考到的Tim Caswell的文章，裡面有一種解法，不過還需要額外包裝（在他的例子中）NodeJS核心的fs物件，把一些函數（例如readFile）用Currying處理。類似像這樣：</p>
<p>var fs = require(&#8216;fs&#8217;);
var readFile = function(path) {</p>
<blockquote>
<div><dl class="docutils">
<dt>return function(callback, errback) {</dt>
<dd><dl class="first docutils">
<dt>fs.readFile(path, function(err, data) {</dt>
<dd><dl class="first docutils">
<dt>if(err) {</dt>
<dd>errback();</dd>
<dt>} else {</dt>
<dd>callback(data);</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<p>};</p>
</div></blockquote>
<p>}</p>
<p>其他部份可以參考Tim Caswell的文章，他的Do.parallel跟上面的wait差不多意思，這裡只提示一下他沒說到的地方。</p>
<p>另外一種做法是去修飾一下callback，當他作為事件處理函數執行後，再用cps的方式取得結果：</p>
<p>&lt;script&gt;
function Wait(fns, done) {</p>
<blockquote>
<div><p>var count = 0;
var results = [];
this.getCallback = function(index) {</p>
<blockquote>
<div><p>count++;
return (function(waitback) {</p>
<blockquote>
<div><dl class="docutils">
<dt>return function() {</dt>
<dd><p class="first">var i=0,args=[];
for(;i&lt;arguments.length;i++) {</p>
<blockquote>
<div>args.push(arguments[i]);</div></blockquote>
<p class="last">}
args.push(waitback);
fns[index].apply(this, args);</p>
</dd>
</dl>
<p>};</p>
</div></blockquote>
<dl class="docutils">
<dt>})(function(result) {</dt>
<dd><p class="first">results.push(result);
if(&#8211;count == 0) {</p>
<blockquote>
<div>done(results);</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>});</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
var a = new Wait(</p>
<blockquote>
<div>[
function(waitback){
console.log(&#8216;done a&#8217;);
var result = 500;
waitback(result)
},
function(waitback){
console.log(&#8216;done b&#8217;);
var result = 1000;
waitback(result)
},
function(waitback){
console.log(&#8216;done c&#8217;);
var result = 1500;
waitback(result)
}
],
function(results){
var ret = 0, i=0;
for(; i&lt;results.length; i++) {
ret += results[i];
}
console.log(&#8216;done all. result: &#8216;+ret);
}</div></blockquote>
<p>);
var callbacks = [a.getCallback(0),a.getCallback(1),a.getCallback(0),a.getCallback(2)];
//一次取出要使用的callbacks，避免結果提早送出
setTimeout(callbacks[0], 500);
setTimeout(callbacks[1], 1000);
setTimeout(callbacks[2], 1500);
setTimeout(callbacks[3], 2000);
//當所有取出的callbacks執行完畢，就呼叫done()來處理結果
&lt;/script&gt;</p>
<p>執行結果：</p>
<p>done a
done b
done a
done c
done all. result: 3500</p>
<p>上面只是一些小實驗，更成熟的作品是Tim Caswell的step：https://github.com/creationix/step</p>
<p>如果希望真正使用同步的方式寫非同步，則需要使用Promise.js這一類的library來轉換非同步函數，不過他結構比較複雜XD（見仁見智，不過有些人認為Promise有點過頭了）：http://blogs.msdn.com/b/rbuckton/archive/2011/08/15/promise-js-2-0-promise-framework-for-javascript.aspx</p>
<p>如果想不透過其他Library做轉換，又能直接用同步方式執行非同步函數，大概就要使用一些需要額外compile原始程式碼的方法了。例如Bruno Jouhier的streamline.js：https://github.com/Sage/streamlinejs</p>
</div>
<div class="section" id="id3">
<h3>循序執行<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>循序執行可以協助把非常深的巢狀callback結構攤平，例如用這樣的簡單模組來做（serial.js）：</p>
<dl class="docutils">
<dt>module.exports = function(funs) {</dt>
<dd><p class="first">var c = 0;
if(!isArrayOfFunctions(funs)) {</p>
<blockquote>
<div>throw(&#8216;Argument type was not matched. Should be array of functions.&#8217;);</div></blockquote>
<p>}
return function() {</p>
<blockquote>
<div><p>var args = Array.prototype.slice.call(arguments, 0);
if(!(c&gt;=funs.length)) {</p>
<blockquote>
<div>c++;
return funs[c-1].apply(this, args);</div></blockquote>
<p>}</p>
</div></blockquote>
<p class="last">};</p>
</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>function isArrayOfFunctions(f) {</dt>
<dd><p class="first">if(typeof f !== &#8216;object&#8217;) return false;
if(!f.length) return false;
if(!f.concat) return false;
if(!f.splice) return false;
var i = 0;
for(; i&lt;f.length; i++) {</p>
<blockquote>
<div>if(typeof f[i] !== &#8216;function&#8217;) return false;</div></blockquote>
<p class="last">}
return true;</p>
</dd>
</dl>
<p>}</p>
<p>簡單的測試範例（testSerial.js），使用fs模組，確定某個path是檔案，然後讀取印出檔案內容。這樣會用到兩層的callback，所以測試中有使用serial的版本與nested callbacks的版本做對照：</p>
<dl class="docutils">
<dt>var serial = require(&#8216;./serial&#8217;),</dt>
<dd><p class="first">fs = require(&#8216;fs&#8217;),
path = &#8216;./dclient.js&#8217;,
cb = serial([
function(err, data) {</p>
<blockquote>
<div><dl class="docutils">
<dt>if(!err) {</dt>
<dd><dl class="first docutils">
<dt>if(data.isFile) {</dt>
<dd>fs.readFile(path, cb);</dd>
</dl>
<p class="last">}</p>
</dd>
<dt>} else {</dt>
<dd>console.log(err);</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>},
function(err, data) {</p>
<blockquote>
<div><dl class="docutils">
<dt>if(!err) {</dt>
<dd>console.log(&#8216;[flattened by searial:]&#8217;);
console.log(data.toString(&#8216;utf8&#8217;));</dd>
<dt>} else {</dt>
<dd>console.log(err);</dd>
</dl>
<p>}</p>
</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>]);
fs.stat(path, cb);</p>
<dl class="docutils">
<dt>fs.stat(path, function(err, data) {</dt>
<dd><p class="first">//第一層callback
if(!err) {</p>
<blockquote>
<div><dl class="docutils">
<dt>if(data.isFile) {</dt>
<dd><dl class="first docutils">
<dt>fs.readFile(path, function(err, data) {</dt>
<dd><p class="first">//第二層callback
if(!err) {</p>
<blockquote>
<div>console.log(&#8216;[nested callbacks:]&#8217;);
console.log(data.toString(&#8216;utf8&#8217;));</div></blockquote>
<dl class="docutils">
<dt>} else {</dt>
<dd>console.log(err);</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p class="last">});</p>
</dd>
<dt>} else {</dt>
<dd>console.log(err);</dd>
</dl>
<p>}</p>
</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p>});</p>
<p>關鍵在於，這些callback的執行是有順序性的，所以利用serial返回的一個函數cb來取代這些callback，然後在cb中控制每次會循序呼叫的函數，就可以把巢狀的callback攤平成循序的function陣列（就是傳給serial函數的參數）。</p>
<p>測試中的./dclient.js是一個簡單的dnode測試程式，放在跟testSerial.js同一個目錄：</p>
<p>var dnode = require(&#8216;dnode&#8217;);</p>
<dl class="docutils">
<dt>dnode.connect(8000, &#8216;localhost&#8217;,  function(remote) {</dt>
<dd><dl class="first docutils">
<dt>remote.restart(function(str) {</dt>
<dd>console.log(str);
process.exit();</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<p>});</p>
<p>執行測試程式後，出現結果：</p>
<p>[flattened by searial:]
var dnode = require(&#8216;dnode&#8217;);</p>
<dl class="docutils">
<dt>dnode.connect(8000, &#8216;localhost&#8217;,  function(remote) {</dt>
<dd><dl class="first docutils">
<dt>remote.restart(function(str) {</dt>
<dd>console.log(str);
process.exit();</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<p>});</p>
<p>[nested callbacks:]
var dnode = require(&#8216;dnode&#8217;);</p>
<dl class="docutils">
<dt>dnode.connect(8000, &#8216;localhost&#8217;,  function(remote) {</dt>
<dd><dl class="first docutils">
<dt>remote.restart(function(str) {</dt>
<dd>console.log(str);
process.exit();</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<p>});</p>
<p>對照起來看，兩種寫法的結果其實是一樣的，但是利用serial.js，巢狀的callback結構就會消失。</p>
<p>不過這樣也只限於順序單純的狀況，如果函數執行的順序比較複雜（不只是一直線），還是需要用功能更完整的流程控制模組比較好，例如 <a class="reference external" href="https://github.com/caolan/async">https://github.com/caolan/async</a> 。</p>
</div>
</div>
</div>



            <div id="disqus_thread"></div>
            <script type="text/javascript">
                /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                var disqus_shortname = 'nodejstwbook'; // required: replace example with your forum shortname
                /* * * DON'T EDIT BELOW THIS LINE * * */
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
  
          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">內容目錄</a></h3>
  <ul>
<li><a class="reference internal" href="#">JavaScript 與 NodeJS</a><ul>
<li><a class="reference internal" href="#event-loop">Event Loop</a></li>
<li><a class="reference internal" href="#scope-closure">Scope 與 Closure</a></li>
<li><a class="reference internal" href="#callback">Callback</a></li>
<li><a class="reference internal" href="#cps-continuation-passing-style">CPS（Continuation-Passing Style）</a></li>
<li><a class="reference internal" href="#currying">函數返回函數與Currying</a></li>
<li><a class="reference internal" href="#id1">流程控制</a><ul>
<li><a class="reference internal" href="#id2">並發與等待</a></li>
<li><a class="reference internal" href="#id3">循序執行</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一個主題</h4>
  <p class="topless"><a href="node_introduce.html"
                        title="上一章">Node.js 簡介</a></p>
  <h4>下一個主題</h4>
  <p class="topless"><a href="node_install.html"
                        title="下一章">Node.js 安裝與設定</a></p>
<div id="searchbox" style="display: none">
  <h3>快速搜尋</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="node_install.html" title="Node.js 安裝與設定"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="node_introduce.html" title="Node.js 簡介"
             >上一頁</a> |</li>
        <li><a href="../index.html">The Little Node.js Book</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    </div>
  </body>
</html>